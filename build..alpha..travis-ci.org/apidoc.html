<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://jshint.com/"

    >jshint (v2.9.4)</a>
</h1>
<h4>Static analysis tool for JavaScript</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint">module jshint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT">
            function <span class="apidocSignatureSpan">jshint.</span>JSHINT
            <span class="apidocSignatureSpan">(s, o, g)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.addModule">
            function <span class="apidocSignatureSpan">jshint.</span>JSHINT.addModule
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.data">
            function <span class="apidocSignatureSpan">jshint.</span>JSHINT.data
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack">
            function <span class="apidocSignatureSpan">jshint.</span>name_stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.scope_manager">
            function <span class="apidocSignatureSpan">jshint.</span>scope_manager
            <span class="apidocSignatureSpan">(state, predefined, exported, declared)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jshint.</span>lex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jshint.</span>name_stack.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jshint.</span>style</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.JSHINT">module jshint.JSHINT</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.JSHINT">
            function <span class="apidocSignatureSpan">jshint.</span>JSHINT
            <span class="apidocSignatureSpan">(s, o, g)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.addModule">
            function <span class="apidocSignatureSpan">jshint.JSHINT.</span>addModule
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.data">
            function <span class="apidocSignatureSpan">jshint.JSHINT.</span>data
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.jshint">
            function <span class="apidocSignatureSpan">jshint.JSHINT.</span>jshint
            <span class="apidocSignatureSpan">(s, o, g)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.JSHINT.addModule">module jshint.JSHINT.addModule</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.addModule.addModule">
            function <span class="apidocSignatureSpan">jshint.JSHINT.</span>addModule
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.JSHINT.data">module jshint.JSHINT.data</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.data.data">
            function <span class="apidocSignatureSpan">jshint.JSHINT.</span>data
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.lex">module jshint.lex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.lex.Lexer">
            function <span class="apidocSignatureSpan">jshint.lex.</span>Lexer
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jshint.lex.</span>Context</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.name_stack">module jshint.name_stack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.name_stack">
            function <span class="apidocSignatureSpan">jshint.</span>name_stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.name_stack.prototype">module jshint.name_stack.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.prototype.infer">
            function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>infer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.prototype.pop">
            function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.prototype.push">
            function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>push
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.prototype.set">
            function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>set
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.scope_manager">module jshint.scope_manager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.scope_manager.scope_manager">
            function <span class="apidocSignatureSpan">jshint.</span>scope_manager
            <span class="apidocSignatureSpan">(state, predefined, exported, declared)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.style">module jshint.style</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.style.register">
            function <span class="apidocSignatureSpan">jshint.style.</span>register
            <span class="apidocSignatureSpan">(linter)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint" id="apidoc.module.jshint">module jshint</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.JSHINT" id="apidoc.element.jshint.JSHINT">
        function <span class="apidocSignatureSpan">jshint.</span>JSHINT
        <span class="apidocSignatureSpan">(s, o, g)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSHINT = function (s, o, g) {
  var x, reIgnoreStr, reIgnore;
  var optionKeys;
  var newOptionObj = {};
  var newIgnoredObj = {};

  o = _.clone(o);
  state.reset();

  if (o &#x26;&#x26; o.scope) {
    JSHINT.scope = o.scope;
  } else {
    JSHINT.errors = [];
    JSHINT.undefs = [];
    JSHINT.internals = [];
    JSHINT.blacklist = {};
    JSHINT.scope = &#x22;(main)&#x22;;
  }

  predefined = Object.create(null);
  combine(predefined, vars.ecmaIdentifiers[3]);
  combine(predefined, vars.reservedVars);

  combine(predefined, g || {});

  declared = Object.create(null);
  var exported = Object.create(null); // Variables that live outside the current file

  function each(obj, cb) {
    if (!obj)
      return;

    if (!Array.isArray(obj) &#x26;&#x26; typeof obj === &#x22;object&#x22;)
      obj = Object.keys(obj);

    obj.forEach(cb);
  }

  if (o) {
    each(o.predef || null, function(item) {
      var slice, prop;

      if (item[0] === &#x22;-&#x22;) {
        slice = item.slice(1);
        JSHINT.blacklist[slice] = slice;
        // remove from predefined if there
        delete predefined[slice];
      } else {
        prop = Object.getOwnPropertyDescriptor(o.predef, item);
        predefined[item] = prop ? prop.value : false;
      }
    });

    each(o.exported || null, function(item) {
      exported[item] = true;
    });

    delete o.predef;
    delete o.exported;

    optionKeys = Object.keys(o);
    for (x = 0; x &#x3c; optionKeys.length; x++) {
      if (/^-W\d{3}$/g.test(optionKeys[x])) {
        newIgnoredObj[optionKeys[x].slice(1)] = true;
      } else {
        var optionKey = optionKeys[x];
        newOptionObj[optionKey] = o[optionKey];
      }
    }
  }

  state.option = newOptionObj;
  state.ignored = newIgnoredObj;

  state.option.indent = state.option.indent || 4;
  state.option.maxerr = state.option.maxerr || 50;

  indent = 1;

  var scopeManagerInst = scopeManager(state, predefined, exported, declared);
  scopeManagerInst.on(&#x22;warning&#x22;, function(ev) {
    warning.apply(null, [ ev.code, ev.token].concat(ev.data));
  });

  scopeManagerInst.on(&#x22;error&#x22;, function(ev) {
    error.apply(null, [ ev.code, ev.token ].concat(ev.data));
  });

  state.funct = functor(&#x22;(global)&#x22;, null, {
    &#x22;(global)&#x22;    : true,
    &#x22;(scope)&#x22;     : scopeManagerInst,
    &#x22;(comparray)&#x22; : arrayComprehension(),
    &#x22;(metrics)&#x22;   : createMetrics(state.tokens.next)
  });

  functions = [state.funct];
  urls = [];
  stack = null;
  member = {};
  membersOnly = null;
  inblock = false;
  lookahead = [];

  if (!isString(s) &#x26;&#x26; !Array.isArray(s)) {
    errorAt(&#x22;E004&#x22;, 0);
    return false;
  }

  api = {
    get isJSON() {
      return state.jsonMode;
    },

    getOption: function(name) {
      return state.option[name] || null;
    },

    getCache: function(name) {
      return state.cache[name];
    },

    setCache: function(name, value) {
      state.cache[name] = value;
    },

    warn: function(code, data) {
      warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
    },

    on: function(names, listener) {
      names.split(&#x22; &#x22;).forEach(function(name) {
        emitter.on(name, listener);
      }.bind(this));
    }
  };

  emitter.removeAllListeners();
  (extraModules || []).forEach(function(func) {
    func(api);
  });

  state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[&#x22;(begin)&#x22;];

  if (o &#x26;&#x26; o.ignoreDelimiters) {

    if (!Array.isArray(o.ignoreDelimiters)) {
      o.ignoreDelimiters = [o.ignoreDelimiters];
    }

    o.ignoreDelimiters.forEach(function(delimiterPair) {
      if (!delimiterPair.start || !delimiterPair.end)
          return;

      reIgnoreStr = escapeRegex(delimiterPair.start) +
                    &#x22;[\\s\\S]*?&#x22; +
                    escapeRegex(delimiterPair.end);

      reIgnore = new RegExp(reIgnoreStr, &#x22;ig&#x22;);

      s = s.replace(reIgnore, function(match) {
        return match.replace(/./g, &#x22; &#x22;);
      });
    });
  }

  lex = new Lexer(s);

  lex.on(&#x22;warning&#x22;, function(ev) {
    warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
  });

  lex.on(&#x22;error&#x22;, function(ev) {
    errorAt.apply(null ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.JSHINT.addModule" id="apidoc.element.jshint.JSHINT.addModule">
        function <span class="apidocSignatureSpan">jshint.</span>JSHINT.addModule
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSHINT.addModule = function (func) {
  extraModules.push(func);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.JSHINT.data" id="apidoc.element.jshint.JSHINT.data">
        function <span class="apidocSignatureSpan">jshint.</span>JSHINT.data
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSHINT.data = function () {
  var data = {
    functions: [],
    options: state.option
  };

  var fu, f, i, j, n, globals;

  if (itself.errors.length) {
    data.errors = itself.errors;
  }

  if (state.jsonMode) {
    data.json = true;
  }

  var impliedGlobals = state.funct[&#x22;(scope)&#x22;].getImpliedGlobals();
  if (impliedGlobals.length &#x3e; 0) {
    data.implieds = impliedGlobals;
  }

  if (urls.length &#x3e; 0) {
    data.urls = urls;
  }

  globals = state.funct[&#x22;(scope)&#x22;].getUsedOrDefinedGlobals();
  if (globals.length &#x3e; 0) {
    data.globals = globals;
  }

  for (i = 1; i &#x3c; functions.length; i += 1) {
    f = functions[i];
    fu = {};

    for (j = 0; j &#x3c; functionicity.length; j += 1) {
      fu[functionicity[j]] = [];
    }

    for (j = 0; j &#x3c; functionicity.length; j += 1) {
      if (fu[functionicity[j]].length === 0) {
        delete fu[functionicity[j]];
      }
    }

    fu.name = f[&#x22;(name)&#x22;];
    fu.param = f[&#x22;(params)&#x22;];
    fu.line = f[&#x22;(line)&#x22;];
    fu.character = f[&#x22;(character)&#x22;];
    fu.last = f[&#x22;(last)&#x22;];
    fu.lastcharacter = f[&#x22;(lastcharacter)&#x22;];

    fu.metrics = {
      complexity: f[&#x22;(metrics)&#x22;].ComplexityCount,
      parameters: f[&#x22;(metrics)&#x22;].arity,
      statements: f[&#x22;(metrics)&#x22;].statementCount
    };

    data.functions.push(fu);
  }

  var unuseds = state.funct[&#x22;(scope)&#x22;].getUnuseds();
  if (unuseds.length &#x3e; 0) {
    data.unused = unuseds;
  }

  for (n in member) {
    if (typeof member[n] === &#x22;number&#x22;) {
      data.member = member;
      break;
    }
  }

  return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.name_stack" id="apidoc.element.jshint.name_stack">
        function <span class="apidocSignatureSpan">jshint.</span>name_stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NameStack() {
  this._stack = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.scope_manager" id="apidoc.element.jshint.scope_manager">
        function <span class="apidocSignatureSpan">jshint.</span>scope_manager
        <span class="apidocSignatureSpan">(state, predefined, exported, declared)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scope_manager = function (state, predefined, exported, declared) {

  var _current;
  var _scopeStack = [];

  function _newScope(type) {
    _current = {
      &#x22;(labels)&#x22;: Object.create(null),
      &#x22;(usages)&#x22;: Object.create(null),
      &#x22;(breakLabels)&#x22;: Object.create(null),
      &#x22;(parent)&#x22;: _current,
      &#x22;(type)&#x22;: type,
      &#x22;(params)&#x22;: (type === &#x22;functionparams&#x22; || type === &#x22;catchparams&#x22;) ? [] : null
    };
    _scopeStack.push(_current);
  }

  _newScope(&#x22;global&#x22;);
  _current[&#x22;(predefined)&#x22;] = predefined;

  var _currentFunctBody = _current; // this is the block after the params = function

  var usedPredefinedAndGlobals = Object.create(null);
  var impliedGlobals = Object.create(null);
  var unuseds = [];
  var emitter = new events.EventEmitter();

  function warning(code, token) {
    emitter.emit(&#x22;warning&#x22;, {
      code: code,
      token: token,
      data: _.slice(arguments, 2)
    });
  }

  function error(code, token) {
    emitter.emit(&#x22;warning&#x22;, {
      code: code,
      token: token,
      data: _.slice(arguments, 2)
    });
  }

  function _setupUsages(labelName) {
    if (!_current[&#x22;(usages)&#x22;][labelName]) {
      _current[&#x22;(usages)&#x22;][labelName] = {
        &#x22;(modified)&#x22;: [],
        &#x22;(reassigned)&#x22;: [],
        &#x22;(tokens)&#x22;: []
      };
    }
  }

  var _getUnusedOption = function(unused_opt) {
    if (unused_opt === undefined) {
      unused_opt = state.option.unused;
    }

    if (unused_opt === true) {
      unused_opt = &#x22;last-param&#x22;;
    }

    return unused_opt;
  };

  var _warnUnused = function(name, tkn, type, unused_opt) {
    var line = tkn.line;
    var chr  = tkn.from;
    var raw_name = tkn.raw_text || name;

    unused_opt = _getUnusedOption(unused_opt);

    var warnable_types = {
      &#x22;vars&#x22;: [&#x22;var&#x22;],
      &#x22;last-param&#x22;: [&#x22;var&#x22;, &#x22;param&#x22;],
      &#x22;strict&#x22;: [&#x22;var&#x22;, &#x22;param&#x22;, &#x22;last-param&#x22;]
    };

    if (unused_opt) {
      if (warnable_types[unused_opt] &#x26;&#x26; warnable_types[unused_opt].indexOf(type) !== -1) {
        warning(&#x22;W098&#x22;, { line: line, from: chr }, raw_name);
      }
    }

    // inconsistent - see gh-1894
    if (unused_opt || type === &#x22;var&#x22;) {
      unuseds.push({
        name: name,
        line: line,
        character: chr
      });
    }
  };

<span class="apidocCodeCommentSpan">  /**
   * Checks the current scope for unused identifiers
   */
</span>  function _checkForUnused() {
    // function params are handled specially
    // assume that parameters are the only thing declared in the param scope
    if (_current[&#x22;(type)&#x22;] === &#x22;functionparams&#x22;) {
      _checkParams();
      return;
    }
    var curentLabels = _current[&#x22;(labels)&#x22;];
    for (var labelName in curentLabels) {
      if (curentLabels[labelName]) {
        if (curentLabels[labelName][&#x22;(type)&#x22;] !== &#x22;exception&#x22; &#x26;&#x26;
          curentLabels[labelName][&#x22;(unused)&#x22;]) {
          _warnUnused(labelName, curentLabels[labelName][&#x22;(token)&#x22;], &#x22;var&#x22;);
        }
      }
    }
  }

  /**
   * Checks the current scope for unused parameters
   * Must be called in a function parameter scope
   */
  function _checkParams() {
    var params = _current[&#x22;(params)&#x22;];

    if (!params) {
      return;
    }

    var param = params.pop();
    var unused_opt;

    while (param) {
      var label = _current[&#x22;(labels)&#x22;][param];

      unused_opt = _getUnusedOption(state.funct[&#x22;(unusedOption)&#x22;]);

      // &#x27;undefined&#x27; is a special case for (function(window, undefined) { ... })();
      // patterns.
      if (param === &#x22;undefined&#x22;)
        return;

      if (label[&#x22;(unused)&#x22;]) {
        _warnUnused(param, label[&#x22;(token)&#x22;], &#x22;param&#x22;, state.funct[&#x22;(unusedOption)&#x22;]);
      } else if (unused_opt === &#x22;last-param&#x22;) {
        return;
      }

      param = params.pop();
    }
  }

  /**
   * Finds the relevant label&#x27;s scope, searching from nearest outwards
   * @returns {Object} the scope the label was found in
   */
  function _getLabel(labelName) {
    for (var i = _scopeStack.length - 1 ; i &#x3e;= 0; --i) {
      var scopeLabels = _scopeStack[i][&#x22;(labels)&#x22;];
      if (scopeLabels[labelName]) {
        return scopeLabels;
      }
    }
  }

  function usedSoFarInCurrentFunction(labelName) {
    // used so far in ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.JSHINT" id="apidoc.module.jshint.JSHINT">module jshint.JSHINT</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.JSHINT.JSHINT" id="apidoc.element.jshint.JSHINT.JSHINT">
        function <span class="apidocSignatureSpan">jshint.</span>JSHINT
        <span class="apidocSignatureSpan">(s, o, g)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSHINT = function (s, o, g) {
  var x, reIgnoreStr, reIgnore;
  var optionKeys;
  var newOptionObj = {};
  var newIgnoredObj = {};

  o = _.clone(o);
  state.reset();

  if (o &#x26;&#x26; o.scope) {
    JSHINT.scope = o.scope;
  } else {
    JSHINT.errors = [];
    JSHINT.undefs = [];
    JSHINT.internals = [];
    JSHINT.blacklist = {};
    JSHINT.scope = &#x22;(main)&#x22;;
  }

  predefined = Object.create(null);
  combine(predefined, vars.ecmaIdentifiers[3]);
  combine(predefined, vars.reservedVars);

  combine(predefined, g || {});

  declared = Object.create(null);
  var exported = Object.create(null); // Variables that live outside the current file

  function each(obj, cb) {
    if (!obj)
      return;

    if (!Array.isArray(obj) &#x26;&#x26; typeof obj === &#x22;object&#x22;)
      obj = Object.keys(obj);

    obj.forEach(cb);
  }

  if (o) {
    each(o.predef || null, function(item) {
      var slice, prop;

      if (item[0] === &#x22;-&#x22;) {
        slice = item.slice(1);
        JSHINT.blacklist[slice] = slice;
        // remove from predefined if there
        delete predefined[slice];
      } else {
        prop = Object.getOwnPropertyDescriptor(o.predef, item);
        predefined[item] = prop ? prop.value : false;
      }
    });

    each(o.exported || null, function(item) {
      exported[item] = true;
    });

    delete o.predef;
    delete o.exported;

    optionKeys = Object.keys(o);
    for (x = 0; x &#x3c; optionKeys.length; x++) {
      if (/^-W\d{3}$/g.test(optionKeys[x])) {
        newIgnoredObj[optionKeys[x].slice(1)] = true;
      } else {
        var optionKey = optionKeys[x];
        newOptionObj[optionKey] = o[optionKey];
      }
    }
  }

  state.option = newOptionObj;
  state.ignored = newIgnoredObj;

  state.option.indent = state.option.indent || 4;
  state.option.maxerr = state.option.maxerr || 50;

  indent = 1;

  var scopeManagerInst = scopeManager(state, predefined, exported, declared);
  scopeManagerInst.on(&#x22;warning&#x22;, function(ev) {
    warning.apply(null, [ ev.code, ev.token].concat(ev.data));
  });

  scopeManagerInst.on(&#x22;error&#x22;, function(ev) {
    error.apply(null, [ ev.code, ev.token ].concat(ev.data));
  });

  state.funct = functor(&#x22;(global)&#x22;, null, {
    &#x22;(global)&#x22;    : true,
    &#x22;(scope)&#x22;     : scopeManagerInst,
    &#x22;(comparray)&#x22; : arrayComprehension(),
    &#x22;(metrics)&#x22;   : createMetrics(state.tokens.next)
  });

  functions = [state.funct];
  urls = [];
  stack = null;
  member = {};
  membersOnly = null;
  inblock = false;
  lookahead = [];

  if (!isString(s) &#x26;&#x26; !Array.isArray(s)) {
    errorAt(&#x22;E004&#x22;, 0);
    return false;
  }

  api = {
    get isJSON() {
      return state.jsonMode;
    },

    getOption: function(name) {
      return state.option[name] || null;
    },

    getCache: function(name) {
      return state.cache[name];
    },

    setCache: function(name, value) {
      state.cache[name] = value;
    },

    warn: function(code, data) {
      warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
    },

    on: function(names, listener) {
      names.split(&#x22; &#x22;).forEach(function(name) {
        emitter.on(name, listener);
      }.bind(this));
    }
  };

  emitter.removeAllListeners();
  (extraModules || []).forEach(function(func) {
    func(api);
  });

  state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[&#x22;(begin)&#x22;];

  if (o &#x26;&#x26; o.ignoreDelimiters) {

    if (!Array.isArray(o.ignoreDelimiters)) {
      o.ignoreDelimiters = [o.ignoreDelimiters];
    }

    o.ignoreDelimiters.forEach(function(delimiterPair) {
      if (!delimiterPair.start || !delimiterPair.end)
          return;

      reIgnoreStr = escapeRegex(delimiterPair.start) +
                    &#x22;[\\s\\S]*?&#x22; +
                    escapeRegex(delimiterPair.end);

      reIgnore = new RegExp(reIgnoreStr, &#x22;ig&#x22;);

      s = s.replace(reIgnore, function(match) {
        return match.replace(/./g, &#x22; &#x22;);
      });
    });
  }

  lex = new Lexer(s);

  lex.on(&#x22;warning&#x22;, function(ev) {
    warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
  });

  lex.on(&#x22;error&#x22;, function(ev) {
    errorAt.apply(null ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.JSHINT.addModule" id="apidoc.element.jshint.JSHINT.addModule">
        function <span class="apidocSignatureSpan">jshint.JSHINT.</span>addModule
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addModule = function (func) {
  extraModules.push(func);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.JSHINT.data" id="apidoc.element.jshint.JSHINT.data">
        function <span class="apidocSignatureSpan">jshint.JSHINT.</span>data
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">data = function () {
  var data = {
    functions: [],
    options: state.option
  };

  var fu, f, i, j, n, globals;

  if (itself.errors.length) {
    data.errors = itself.errors;
  }

  if (state.jsonMode) {
    data.json = true;
  }

  var impliedGlobals = state.funct[&#x22;(scope)&#x22;].getImpliedGlobals();
  if (impliedGlobals.length &#x3e; 0) {
    data.implieds = impliedGlobals;
  }

  if (urls.length &#x3e; 0) {
    data.urls = urls;
  }

  globals = state.funct[&#x22;(scope)&#x22;].getUsedOrDefinedGlobals();
  if (globals.length &#x3e; 0) {
    data.globals = globals;
  }

  for (i = 1; i &#x3c; functions.length; i += 1) {
    f = functions[i];
    fu = {};

    for (j = 0; j &#x3c; functionicity.length; j += 1) {
      fu[functionicity[j]] = [];
    }

    for (j = 0; j &#x3c; functionicity.length; j += 1) {
      if (fu[functionicity[j]].length === 0) {
        delete fu[functionicity[j]];
      }
    }

    fu.name = f[&#x22;(name)&#x22;];
    fu.param = f[&#x22;(params)&#x22;];
    fu.line = f[&#x22;(line)&#x22;];
    fu.character = f[&#x22;(character)&#x22;];
    fu.last = f[&#x22;(last)&#x22;];
    fu.lastcharacter = f[&#x22;(lastcharacter)&#x22;];

    fu.metrics = {
      complexity: f[&#x22;(metrics)&#x22;].ComplexityCount,
      parameters: f[&#x22;(metrics)&#x22;].arity,
      statements: f[&#x22;(metrics)&#x22;].statementCount
    };

    data.functions.push(fu);
  }

  var unuseds = state.funct[&#x22;(scope)&#x22;].getUnuseds();
  if (unuseds.length &#x3e; 0) {
    data.unused = unuseds;
  }

  for (n in member) {
    if (typeof member[n] === &#x22;number&#x22;) {
      data.member = member;
      break;
    }
  }

  return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.JSHINT.jshint" id="apidoc.element.jshint.JSHINT.jshint">
        function <span class="apidocSignatureSpan">jshint.JSHINT.</span>jshint
        <span class="apidocSignatureSpan">(s, o, g)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jshint = function (s, o, g) {
  var x, reIgnoreStr, reIgnore;
  var optionKeys;
  var newOptionObj = {};
  var newIgnoredObj = {};

  o = _.clone(o);
  state.reset();

  if (o &#x26;&#x26; o.scope) {
    JSHINT.scope = o.scope;
  } else {
    JSHINT.errors = [];
    JSHINT.undefs = [];
    JSHINT.internals = [];
    JSHINT.blacklist = {};
    JSHINT.scope = &#x22;(main)&#x22;;
  }

  predefined = Object.create(null);
  combine(predefined, vars.ecmaIdentifiers[3]);
  combine(predefined, vars.reservedVars);

  combine(predefined, g || {});

  declared = Object.create(null);
  var exported = Object.create(null); // Variables that live outside the current file

  function each(obj, cb) {
    if (!obj)
      return;

    if (!Array.isArray(obj) &#x26;&#x26; typeof obj === &#x22;object&#x22;)
      obj = Object.keys(obj);

    obj.forEach(cb);
  }

  if (o) {
    each(o.predef || null, function(item) {
      var slice, prop;

      if (item[0] === &#x22;-&#x22;) {
        slice = item.slice(1);
        JSHINT.blacklist[slice] = slice;
        // remove from predefined if there
        delete predefined[slice];
      } else {
        prop = Object.getOwnPropertyDescriptor(o.predef, item);
        predefined[item] = prop ? prop.value : false;
      }
    });

    each(o.exported || null, function(item) {
      exported[item] = true;
    });

    delete o.predef;
    delete o.exported;

    optionKeys = Object.keys(o);
    for (x = 0; x &#x3c; optionKeys.length; x++) {
      if (/^-W\d{3}$/g.test(optionKeys[x])) {
        newIgnoredObj[optionKeys[x].slice(1)] = true;
      } else {
        var optionKey = optionKeys[x];
        newOptionObj[optionKey] = o[optionKey];
      }
    }
  }

  state.option = newOptionObj;
  state.ignored = newIgnoredObj;

  state.option.indent = state.option.indent || 4;
  state.option.maxerr = state.option.maxerr || 50;

  indent = 1;

  var scopeManagerInst = scopeManager(state, predefined, exported, declared);
  scopeManagerInst.on(&#x22;warning&#x22;, function(ev) {
    warning.apply(null, [ ev.code, ev.token].concat(ev.data));
  });

  scopeManagerInst.on(&#x22;error&#x22;, function(ev) {
    error.apply(null, [ ev.code, ev.token ].concat(ev.data));
  });

  state.funct = functor(&#x22;(global)&#x22;, null, {
    &#x22;(global)&#x22;    : true,
    &#x22;(scope)&#x22;     : scopeManagerInst,
    &#x22;(comparray)&#x22; : arrayComprehension(),
    &#x22;(metrics)&#x22;   : createMetrics(state.tokens.next)
  });

  functions = [state.funct];
  urls = [];
  stack = null;
  member = {};
  membersOnly = null;
  inblock = false;
  lookahead = [];

  if (!isString(s) &#x26;&#x26; !Array.isArray(s)) {
    errorAt(&#x22;E004&#x22;, 0);
    return false;
  }

  api = {
    get isJSON() {
      return state.jsonMode;
    },

    getOption: function(name) {
      return state.option[name] || null;
    },

    getCache: function(name) {
      return state.cache[name];
    },

    setCache: function(name, value) {
      state.cache[name] = value;
    },

    warn: function(code, data) {
      warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
    },

    on: function(names, listener) {
      names.split(&#x22; &#x22;).forEach(function(name) {
        emitter.on(name, listener);
      }.bind(this));
    }
  };

  emitter.removeAllListeners();
  (extraModules || []).forEach(function(func) {
    func(api);
  });

  state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[&#x22;(begin)&#x22;];

  if (o &#x26;&#x26; o.ignoreDelimiters) {

    if (!Array.isArray(o.ignoreDelimiters)) {
      o.ignoreDelimiters = [o.ignoreDelimiters];
    }

    o.ignoreDelimiters.forEach(function(delimiterPair) {
      if (!delimiterPair.start || !delimiterPair.end)
          return;

      reIgnoreStr = escapeRegex(delimiterPair.start) +
                    &#x22;[\\s\\S]*?&#x22; +
                    escapeRegex(delimiterPair.end);

      reIgnore = new RegExp(reIgnoreStr, &#x22;ig&#x22;);

      s = s.replace(reIgnore, function(match) {
        return match.replace(/./g, &#x22; &#x22;);
      });
    });
  }

  lex = new Lexer(s);

  lex.on(&#x22;warning&#x22;, function(ev) {
    warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
  });

  lex.on(&#x22;error&#x22;, function(ev) {
    errorAt.apply(null ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.JSHINT.addModule" id="apidoc.module.jshint.JSHINT.addModule">module jshint.JSHINT.addModule</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.JSHINT.addModule.addModule" id="apidoc.element.jshint.JSHINT.addModule.addModule">
        function <span class="apidocSignatureSpan">jshint.JSHINT.</span>addModule
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addModule = function (func) {
  extraModules.push(func);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.JSHINT.data" id="apidoc.module.jshint.JSHINT.data">module jshint.JSHINT.data</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.JSHINT.data.data" id="apidoc.element.jshint.JSHINT.data.data">
        function <span class="apidocSignatureSpan">jshint.JSHINT.</span>data
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">data = function () {
  var data = {
    functions: [],
    options: state.option
  };

  var fu, f, i, j, n, globals;

  if (itself.errors.length) {
    data.errors = itself.errors;
  }

  if (state.jsonMode) {
    data.json = true;
  }

  var impliedGlobals = state.funct[&#x22;(scope)&#x22;].getImpliedGlobals();
  if (impliedGlobals.length &#x3e; 0) {
    data.implieds = impliedGlobals;
  }

  if (urls.length &#x3e; 0) {
    data.urls = urls;
  }

  globals = state.funct[&#x22;(scope)&#x22;].getUsedOrDefinedGlobals();
  if (globals.length &#x3e; 0) {
    data.globals = globals;
  }

  for (i = 1; i &#x3c; functions.length; i += 1) {
    f = functions[i];
    fu = {};

    for (j = 0; j &#x3c; functionicity.length; j += 1) {
      fu[functionicity[j]] = [];
    }

    for (j = 0; j &#x3c; functionicity.length; j += 1) {
      if (fu[functionicity[j]].length === 0) {
        delete fu[functionicity[j]];
      }
    }

    fu.name = f[&#x22;(name)&#x22;];
    fu.param = f[&#x22;(params)&#x22;];
    fu.line = f[&#x22;(line)&#x22;];
    fu.character = f[&#x22;(character)&#x22;];
    fu.last = f[&#x22;(last)&#x22;];
    fu.lastcharacter = f[&#x22;(lastcharacter)&#x22;];

    fu.metrics = {
      complexity: f[&#x22;(metrics)&#x22;].ComplexityCount,
      parameters: f[&#x22;(metrics)&#x22;].arity,
      statements: f[&#x22;(metrics)&#x22;].statementCount
    };

    data.functions.push(fu);
  }

  var unuseds = state.funct[&#x22;(scope)&#x22;].getUnuseds();
  if (unuseds.length &#x3e; 0) {
    data.unused = unuseds;
  }

  for (n in member) {
    if (typeof member[n] === &#x22;number&#x22;) {
      data.member = member;
      break;
    }
  }

  return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.lex" id="apidoc.module.jshint.lex">module jshint.lex</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.lex.Lexer" id="apidoc.element.jshint.lex.Lexer">
        function <span class="apidocSignatureSpan">jshint.lex.</span>Lexer
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(source) {
  var lines = source;

  if (typeof lines === &#x22;string&#x22;) {
    lines = lines
      .replace(/\r\n/g, &#x22;\n&#x22;)
      .replace(/\r/g, &#x22;\n&#x22;)
      .split(&#x22;\n&#x22;);
  }

  // If the first line is a shebang (#!), make it a blank and move on.
  // Shebangs are used by Node scripts.

  if (lines[0] &#x26;&#x26; lines[0].substr(0, 2) === &#x22;#!&#x22;) {
    if (lines[0].indexOf(&#x22;node&#x22;) !== -1) {
      state.option.node = true;
    }
    lines[0] = &#x22;&#x22;;
  }

  this.emitter = new events.EventEmitter();
  this.source = source;
  this.setLines(lines);
  this.prereg = true;

  this.line = 0;
  this.char = 1;
  this.from = 1;
  this.input = &#x22;&#x22;;
  this.inComment = false;
  this.context = [];
  this.templateStarts = [];

  for (var i = 0; i &#x3c; state.option.indent; i += 1) {
    state.tab += &#x22; &#x22;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.name_stack" id="apidoc.module.jshint.name_stack">module jshint.name_stack</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.name_stack.name_stack" id="apidoc.element.jshint.name_stack.name_stack">
        function <span class="apidocSignatureSpan">jshint.</span>name_stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NameStack() {
  this._stack = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.name_stack.prototype" id="apidoc.module.jshint.name_stack.prototype">module jshint.name_stack.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.name_stack.prototype.infer" id="apidoc.element.jshint.name_stack.prototype.infer">
        function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>infer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">infer = function () {
  var nameToken = this._stack[this.length - 1];
  var prefix = &#x22;&#x22;;
  var type;

  // During expected operation, the topmost entry on the stack will only
  // reflect the current function&#x27;s name when the function is declared without
  // the `function` keyword (i.e. for in-line accessor methods). In other
  // cases, the `function` expression itself will introduce an empty entry on
  // the top of the stack, and this should be ignored.
  if (!nameToken || nameToken.type === &#x22;class&#x22;) {
    nameToken = this._stack[this.length - 2];
  }

  if (!nameToken) {
    return &#x22;(empty)&#x22;;
  }

  type = nameToken.type;

  if (type !== &#x22;(string)&#x22; &#x26;&#x26; type !== &#x22;(number)&#x22; &#x26;&#x26; type !== &#x22;(identifier)&#x22; &#x26;&#x26; type !== &#x22;default&#x22;) {
    return &#x22;(expression)&#x22;;
  }

  if (nameToken.accessorType) {
    prefix = nameToken.accessorType + &#x22; &#x22;;
  }

  return prefix + nameToken.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.name_stack.prototype.pop" id="apidoc.element.jshint.name_stack.prototype.pop">
        function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  this._stack.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

pushContext: function(ctxType) {
  this.context.push({ type: ctxType });
},

popContext: function() {
  return this.context.<span class="apidocCodeKeywordSpan">pop</span>();
},

isContext: function(context) {
  return this.context.length &#x3e; 0 &#x26;&#x26; this.context[this.context.length - 1] === context;
},

currentContext: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.name_stack.prototype.push" id="apidoc.element.jshint.name_stack.prototype.push">
        function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>push
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function () {
  this._stack.push(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// environment state.

function asyncTrigger() {
  var _checks = [];

  return {
push: function(fn) {
  _checks.<span class="apidocCodeKeywordSpan">push</span>(fn);
},

check: function() {
  for (var check = 0; check &#x3c; _checks.length; ++check) {
    _checks[check]();
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.name_stack.prototype.set" id="apidoc.element.jshint.name_stack.prototype.set">
        function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>set
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (token) {
  this._stack[this.length - 1] = token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.scope_manager" id="apidoc.module.jshint.scope_manager">module jshint.scope_manager</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.scope_manager.scope_manager" id="apidoc.element.jshint.scope_manager.scope_manager">
        function <span class="apidocSignatureSpan">jshint.</span>scope_manager
        <span class="apidocSignatureSpan">(state, predefined, exported, declared)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scope_manager = function (state, predefined, exported, declared) {

  var _current;
  var _scopeStack = [];

  function _newScope(type) {
    _current = {
      &#x22;(labels)&#x22;: Object.create(null),
      &#x22;(usages)&#x22;: Object.create(null),
      &#x22;(breakLabels)&#x22;: Object.create(null),
      &#x22;(parent)&#x22;: _current,
      &#x22;(type)&#x22;: type,
      &#x22;(params)&#x22;: (type === &#x22;functionparams&#x22; || type === &#x22;catchparams&#x22;) ? [] : null
    };
    _scopeStack.push(_current);
  }

  _newScope(&#x22;global&#x22;);
  _current[&#x22;(predefined)&#x22;] = predefined;

  var _currentFunctBody = _current; // this is the block after the params = function

  var usedPredefinedAndGlobals = Object.create(null);
  var impliedGlobals = Object.create(null);
  var unuseds = [];
  var emitter = new events.EventEmitter();

  function warning(code, token) {
    emitter.emit(&#x22;warning&#x22;, {
      code: code,
      token: token,
      data: _.slice(arguments, 2)
    });
  }

  function error(code, token) {
    emitter.emit(&#x22;warning&#x22;, {
      code: code,
      token: token,
      data: _.slice(arguments, 2)
    });
  }

  function _setupUsages(labelName) {
    if (!_current[&#x22;(usages)&#x22;][labelName]) {
      _current[&#x22;(usages)&#x22;][labelName] = {
        &#x22;(modified)&#x22;: [],
        &#x22;(reassigned)&#x22;: [],
        &#x22;(tokens)&#x22;: []
      };
    }
  }

  var _getUnusedOption = function(unused_opt) {
    if (unused_opt === undefined) {
      unused_opt = state.option.unused;
    }

    if (unused_opt === true) {
      unused_opt = &#x22;last-param&#x22;;
    }

    return unused_opt;
  };

  var _warnUnused = function(name, tkn, type, unused_opt) {
    var line = tkn.line;
    var chr  = tkn.from;
    var raw_name = tkn.raw_text || name;

    unused_opt = _getUnusedOption(unused_opt);

    var warnable_types = {
      &#x22;vars&#x22;: [&#x22;var&#x22;],
      &#x22;last-param&#x22;: [&#x22;var&#x22;, &#x22;param&#x22;],
      &#x22;strict&#x22;: [&#x22;var&#x22;, &#x22;param&#x22;, &#x22;last-param&#x22;]
    };

    if (unused_opt) {
      if (warnable_types[unused_opt] &#x26;&#x26; warnable_types[unused_opt].indexOf(type) !== -1) {
        warning(&#x22;W098&#x22;, { line: line, from: chr }, raw_name);
      }
    }

    // inconsistent - see gh-1894
    if (unused_opt || type === &#x22;var&#x22;) {
      unuseds.push({
        name: name,
        line: line,
        character: chr
      });
    }
  };

<span class="apidocCodeCommentSpan">  /**
   * Checks the current scope for unused identifiers
   */
</span>  function _checkForUnused() {
    // function params are handled specially
    // assume that parameters are the only thing declared in the param scope
    if (_current[&#x22;(type)&#x22;] === &#x22;functionparams&#x22;) {
      _checkParams();
      return;
    }
    var curentLabels = _current[&#x22;(labels)&#x22;];
    for (var labelName in curentLabels) {
      if (curentLabels[labelName]) {
        if (curentLabels[labelName][&#x22;(type)&#x22;] !== &#x22;exception&#x22; &#x26;&#x26;
          curentLabels[labelName][&#x22;(unused)&#x22;]) {
          _warnUnused(labelName, curentLabels[labelName][&#x22;(token)&#x22;], &#x22;var&#x22;);
        }
      }
    }
  }

  /**
   * Checks the current scope for unused parameters
   * Must be called in a function parameter scope
   */
  function _checkParams() {
    var params = _current[&#x22;(params)&#x22;];

    if (!params) {
      return;
    }

    var param = params.pop();
    var unused_opt;

    while (param) {
      var label = _current[&#x22;(labels)&#x22;][param];

      unused_opt = _getUnusedOption(state.funct[&#x22;(unusedOption)&#x22;]);

      // &#x27;undefined&#x27; is a special case for (function(window, undefined) { ... })();
      // patterns.
      if (param === &#x22;undefined&#x22;)
        return;

      if (label[&#x22;(unused)&#x22;]) {
        _warnUnused(param, label[&#x22;(token)&#x22;], &#x22;param&#x22;, state.funct[&#x22;(unusedOption)&#x22;]);
      } else if (unused_opt === &#x22;last-param&#x22;) {
        return;
      }

      param = params.pop();
    }
  }

  /**
   * Finds the relevant label&#x27;s scope, searching from nearest outwards
   * @returns {Object} the scope the label was found in
   */
  function _getLabel(labelName) {
    for (var i = _scopeStack.length - 1 ; i &#x3e;= 0; --i) {
      var scopeLabels = _scopeStack[i][&#x22;(labels)&#x22;];
      if (scopeLabels[labelName]) {
        return scopeLabels;
      }
    }
  }

  function usedSoFarInCurrentFunction(labelName) {
    // used so far in ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.style" id="apidoc.module.jshint.style">module jshint.style</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.style.register" id="apidoc.element.jshint.style.register">
        function <span class="apidocSignatureSpan">jshint.style.</span>register
        <span class="apidocSignatureSpan">(linter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (linter) {
  // Check for properties named __proto__. This special property was
  // deprecated and then re-introduced for ES6.

  linter.on(&#x22;Identifier&#x22;, function style_scanProto(data) {
    if (linter.getOption(&#x22;proto&#x22;)) {
      return;
    }

    if (data.name === &#x22;__proto__&#x22;) {
      linter.warn(&#x22;W103&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.name, &#x22;6&#x22; ]
      });
    }
  });

  // Check for properties named __iterator__. This is a special property
  // available only in browsers with JavaScript 1.7 implementation, but
  // it is deprecated for ES6

  linter.on(&#x22;Identifier&#x22;, function style_scanIterator(data) {
    if (linter.getOption(&#x22;iterator&#x22;)) {
      return;
    }

    if (data.name === &#x22;__iterator__&#x22;) {
      linter.warn(&#x22;W103&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.name ]
      });
    }
  });

  // Check that all identifiers are using camelCase notation.
  // Exceptions: names like MY_VAR and _myVar.

  linter.on(&#x22;Identifier&#x22;, function style_scanCamelCase(data) {
    if (!linter.getOption(&#x22;camelcase&#x22;)) {
      return;
    }

    if (data.name.replace(/^_+|_+$/g, &#x22;&#x22;).indexOf(&#x22;_&#x22;) &#x3e; -1 &#x26;&#x26; !data.name.match(/^[A-Z0-9_]*$/)) {
      linter.warn(&#x22;W106&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.name ]
      });
    }
  });

  // Enforce consistency in style of quoting.

  linter.on(&#x22;String&#x22;, function style_scanQuotes(data) {
    var quotmark = linter.getOption(&#x22;quotmark&#x22;);
    var code;

    if (!quotmark) {
      return;
    }

    // If quotmark is set to &#x27;single&#x27; warn about all double-quotes.

    if (quotmark === &#x22;single&#x22; &#x26;&#x26; data.quote !== &#x22;&#x27;&#x22;) {
      code = &#x22;W109&#x22;;
    }

    // If quotmark is set to &#x27;double&#x27; warn about all single-quotes.

    if (quotmark === &#x22;double&#x22; &#x26;&#x26; data.quote !== &#x22;\&#x22;&#x22;) {
      code = &#x22;W108&#x22;;
    }

    // If quotmark is set to true, remember the first quotation style
    // and then warn about all others.

    if (quotmark === true) {
      if (!linter.getCache(&#x22;quotmark&#x22;)) {
        linter.setCache(&#x22;quotmark&#x22;, data.quote);
      }

      if (linter.getCache(&#x22;quotmark&#x22;) !== data.quote) {
        code = &#x22;W110&#x22;;
      }
    }

    if (code) {
      linter.warn(code, {
        line: data.line,
        char: data.char,
      });
    }
  });

  linter.on(&#x22;Number&#x22;, function style_scanNumbers(data) {
    if (data.value.charAt(0) === &#x22;.&#x22;) {
      // Warn about a leading decimal point.
      linter.warn(&#x22;W008&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.value ]
      });
    }

    if (data.value.substr(data.value.length - 1) === &#x22;.&#x22;) {
      // Warn about a trailing decimal point.
      linter.warn(&#x22;W047&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.value ]
      });
    }

    if (/^00+/.test(data.value)) {
      // Multiple leading zeroes.
      linter.warn(&#x22;W046&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.value ]
      });
    }
  });

  // Warn about script URLs.

  linter.on(&#x22;String&#x22;, function style_scanJavaScriptURLs(data) {
    var re = /^(?:javascript|jscript|ecmascript|vbscript|livescript)\s*:/i;

    if (linter.getOption(&#x22;scripturl&#x22;)) {
      return;
    }

    if (re.test(data.value)) {
      linter.warn(&#x22;W107&#x22;, {
        line: data.line,
        char: data.char
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
