<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://jshint.com/"

    >jshint (v2.9.4)</a>
</h1>
<h4>Static analysis tool for JavaScript</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint">module jshint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT">
            function <span class="apidocSignatureSpan">jshint.</span>JSHINT
            <span class="apidocSignatureSpan">(s, o, g)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack">
            function <span class="apidocSignatureSpan">jshint.</span>name_stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>jshint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jshint.</span>lex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jshint.</span>name_stack.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jshint.</span>style</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.JSHINT">module jshint.JSHINT</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.JSHINT">
            function <span class="apidocSignatureSpan">jshint.</span>JSHINT
            <span class="apidocSignatureSpan">(s, o, g)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.addModule">
            function <span class="apidocSignatureSpan">jshint.JSHINT.</span>addModule
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.data">
            function <span class="apidocSignatureSpan">jshint.JSHINT.</span>data
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.JSHINT.jshint">
            function <span class="apidocSignatureSpan">jshint.JSHINT.</span>jshint
            <span class="apidocSignatureSpan">(s, o, g)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.jshint">module jshint.jshint</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.jshint.JSHINT">
            function <span class="apidocSignatureSpan">jshint.jshint.</span>JSHINT
            <span class="apidocSignatureSpan">(s, o, g)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.lex">module jshint.lex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.lex.Lexer">
            function <span class="apidocSignatureSpan">jshint.lex.</span>Lexer
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jshint.lex.</span>Context</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.name_stack">module jshint.name_stack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.name_stack">
            function <span class="apidocSignatureSpan">jshint.</span>name_stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.name_stack.prototype">module jshint.name_stack.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.prototype.infer">
            function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>infer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.prototype.pop">
            function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.prototype.push">
            function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>push
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.name_stack.prototype.set">
            function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>set
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jshint.style">module jshint.style</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jshint.style.register">
            function <span class="apidocSignatureSpan">jshint.style.</span>register
            <span class="apidocSignatureSpan">(linter)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint" id="apidoc.module.jshint">module jshint</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.JSHINT" id="apidoc.element.jshint.JSHINT">
        function <span class="apidocSignatureSpan">jshint.</span>JSHINT
        <span class="apidocSignatureSpan">(s, o, g)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSHINT = function (s, o, g) {
  var x, reIgnoreStr, reIgnore;
  var optionKeys;
  var newOptionObj = {};
  var newIgnoredObj = {};

  o = _.clone(o);
  state.reset();

  if (o &#x26;&#x26; o.scope) {
    JSHINT.scope = o.scope;
  } else {
    JSHINT.errors = [];
    JSHINT.undefs = [];
    JSHINT.internals = [];
    JSHINT.blacklist = {};
    JSHINT.scope = &#x22;(main)&#x22;;
  }

  predefined = Object.create(null);
  combine(predefined, vars.ecmaIdentifiers[3]);
  combine(predefined, vars.reservedVars);

  combine(predefined, g || {});

  declared = Object.create(null);
  var exported = Object.create(null); // Variables that live outside the current file

  function each(obj, cb) {
    if (!obj)
      return;

    if (!Array.isArray(obj) &#x26;&#x26; typeof obj === &#x22;object&#x22;)
      obj = Object.keys(obj);

    obj.forEach(cb);
  }

  if (o) {
    each(o.predef || null, function(item) {
      var slice, prop;

      if (item[0] === &#x22;-&#x22;) {
        slice = item.slice(1);
        JSHINT.blacklist[slice] = slice;
        // remove from predefined if there
        delete predefined[slice];
      } else {
        prop = Object.getOwnPropertyDescriptor(o.predef, item);
        predefined[item] = prop ? prop.value : false;
      }
    });

    each(o.exported || null, function(item) {
      exported[item] = true;
    });

    delete o.predef;
    delete o.exported;

    optionKeys = Object.keys(o);
    for (x = 0; x &#x3c; optionKeys.length; x++) {
      if (/^-W\d{3}$/g.test(optionKeys[x])) {
        newIgnoredObj[optionKeys[x].slice(1)] = true;
      } else {
        var optionKey = optionKeys[x];
        newOptionObj[optionKey] = o[optionKey];
      }
    }
  }

  state.option = newOptionObj;
  state.ignored = newIgnoredObj;

  state.option.indent = state.option.indent || 4;
  state.option.maxerr = state.option.maxerr || 50;

  indent = 1;

  var scopeManagerInst = scopeManager(state, predefined, exported, declared);
  scopeManagerInst.on(&#x22;warning&#x22;, function(ev) {
    warning.apply(null, [ ev.code, ev.token].concat(ev.data));
  });

  scopeManagerInst.on(&#x22;error&#x22;, function(ev) {
    error.apply(null, [ ev.code, ev.token ].concat(ev.data));
  });

  state.funct = functor(&#x22;(global)&#x22;, null, {
    &#x22;(global)&#x22;    : true,
    &#x22;(scope)&#x22;     : scopeManagerInst,
    &#x22;(comparray)&#x22; : arrayComprehension(),
    &#x22;(metrics)&#x22;   : createMetrics(state.tokens.next)
  });

  functions = [state.funct];
  urls = [];
  stack = null;
  member = {};
  membersOnly = null;
  inblock = false;
  lookahead = [];

  if (!isString(s) &#x26;&#x26; !Array.isArray(s)) {
    errorAt(&#x22;E004&#x22;, 0);
    return false;
  }

  api = {
    get isJSON() {
      return state.jsonMode;
    },

    getOption: function(name) {
      return state.option[name] || null;
    },

    getCache: function(name) {
      return state.cache[name];
    },

    setCache: function(name, value) {
      state.cache[name] = value;
    },

    warn: function(code, data) {
      warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
    },

    on: function(names, listener) {
      names.split(&#x22; &#x22;).forEach(function(name) {
        emitter.on(name, listener);
      }.bind(this));
    }
  };

  emitter.removeAllListeners();
  (extraModules || []).forEach(function(func) {
    func(api);
  });

  state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[&#x22;(begin)&#x22;];

  if (o &#x26;&#x26; o.ignoreDelimiters) {

    if (!Array.isArray(o.ignoreDelimiters)) {
      o.ignoreDelimiters = [o.ignoreDelimiters];
    }

    o.ignoreDelimiters.forEach(function(delimiterPair) {
      if (!delimiterPair.start || !delimiterPair.end)
          return;

      reIgnoreStr = escapeRegex(delimiterPair.start) +
                    &#x22;[\\s\\S]*?&#x22; +
                    escapeRegex(delimiterPair.end);

      reIgnore = new RegExp(reIgnoreStr, &#x22;ig&#x22;);

      s = s.replace(reIgnore, function(match) {
        return match.replace(/./g, &#x22; &#x22;);
      });
    });
  }

  lex = new Lexer(s);

  lex.on(&#x22;warning&#x22;, function(ev) {
    warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
  });

  lex.on(&#x22;error&#x22;, function(ev) {
    errorAt.apply(null ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.name_stack" id="apidoc.element.jshint.name_stack">
        function <span class="apidocSignatureSpan">jshint.</span>name_stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NameStack() {
  this._stack = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.JSHINT" id="apidoc.module.jshint.JSHINT">module jshint.JSHINT</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.JSHINT.JSHINT" id="apidoc.element.jshint.JSHINT.JSHINT">
        function <span class="apidocSignatureSpan">jshint.</span>JSHINT
        <span class="apidocSignatureSpan">(s, o, g)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSHINT = function (s, o, g) {
  var x, reIgnoreStr, reIgnore;
  var optionKeys;
  var newOptionObj = {};
  var newIgnoredObj = {};

  o = _.clone(o);
  state.reset();

  if (o &#x26;&#x26; o.scope) {
    JSHINT.scope = o.scope;
  } else {
    JSHINT.errors = [];
    JSHINT.undefs = [];
    JSHINT.internals = [];
    JSHINT.blacklist = {};
    JSHINT.scope = &#x22;(main)&#x22;;
  }

  predefined = Object.create(null);
  combine(predefined, vars.ecmaIdentifiers[3]);
  combine(predefined, vars.reservedVars);

  combine(predefined, g || {});

  declared = Object.create(null);
  var exported = Object.create(null); // Variables that live outside the current file

  function each(obj, cb) {
    if (!obj)
      return;

    if (!Array.isArray(obj) &#x26;&#x26; typeof obj === &#x22;object&#x22;)
      obj = Object.keys(obj);

    obj.forEach(cb);
  }

  if (o) {
    each(o.predef || null, function(item) {
      var slice, prop;

      if (item[0] === &#x22;-&#x22;) {
        slice = item.slice(1);
        JSHINT.blacklist[slice] = slice;
        // remove from predefined if there
        delete predefined[slice];
      } else {
        prop = Object.getOwnPropertyDescriptor(o.predef, item);
        predefined[item] = prop ? prop.value : false;
      }
    });

    each(o.exported || null, function(item) {
      exported[item] = true;
    });

    delete o.predef;
    delete o.exported;

    optionKeys = Object.keys(o);
    for (x = 0; x &#x3c; optionKeys.length; x++) {
      if (/^-W\d{3}$/g.test(optionKeys[x])) {
        newIgnoredObj[optionKeys[x].slice(1)] = true;
      } else {
        var optionKey = optionKeys[x];
        newOptionObj[optionKey] = o[optionKey];
      }
    }
  }

  state.option = newOptionObj;
  state.ignored = newIgnoredObj;

  state.option.indent = state.option.indent || 4;
  state.option.maxerr = state.option.maxerr || 50;

  indent = 1;

  var scopeManagerInst = scopeManager(state, predefined, exported, declared);
  scopeManagerInst.on(&#x22;warning&#x22;, function(ev) {
    warning.apply(null, [ ev.code, ev.token].concat(ev.data));
  });

  scopeManagerInst.on(&#x22;error&#x22;, function(ev) {
    error.apply(null, [ ev.code, ev.token ].concat(ev.data));
  });

  state.funct = functor(&#x22;(global)&#x22;, null, {
    &#x22;(global)&#x22;    : true,
    &#x22;(scope)&#x22;     : scopeManagerInst,
    &#x22;(comparray)&#x22; : arrayComprehension(),
    &#x22;(metrics)&#x22;   : createMetrics(state.tokens.next)
  });

  functions = [state.funct];
  urls = [];
  stack = null;
  member = {};
  membersOnly = null;
  inblock = false;
  lookahead = [];

  if (!isString(s) &#x26;&#x26; !Array.isArray(s)) {
    errorAt(&#x22;E004&#x22;, 0);
    return false;
  }

  api = {
    get isJSON() {
      return state.jsonMode;
    },

    getOption: function(name) {
      return state.option[name] || null;
    },

    getCache: function(name) {
      return state.cache[name];
    },

    setCache: function(name, value) {
      state.cache[name] = value;
    },

    warn: function(code, data) {
      warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
    },

    on: function(names, listener) {
      names.split(&#x22; &#x22;).forEach(function(name) {
        emitter.on(name, listener);
      }.bind(this));
    }
  };

  emitter.removeAllListeners();
  (extraModules || []).forEach(function(func) {
    func(api);
  });

  state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[&#x22;(begin)&#x22;];

  if (o &#x26;&#x26; o.ignoreDelimiters) {

    if (!Array.isArray(o.ignoreDelimiters)) {
      o.ignoreDelimiters = [o.ignoreDelimiters];
    }

    o.ignoreDelimiters.forEach(function(delimiterPair) {
      if (!delimiterPair.start || !delimiterPair.end)
          return;

      reIgnoreStr = escapeRegex(delimiterPair.start) +
                    &#x22;[\\s\\S]*?&#x22; +
                    escapeRegex(delimiterPair.end);

      reIgnore = new RegExp(reIgnoreStr, &#x22;ig&#x22;);

      s = s.replace(reIgnore, function(match) {
        return match.replace(/./g, &#x22; &#x22;);
      });
    });
  }

  lex = new Lexer(s);

  lex.on(&#x22;warning&#x22;, function(ev) {
    warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
  });

  lex.on(&#x22;error&#x22;, function(ev) {
    errorAt.apply(null ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.JSHINT.addModule" id="apidoc.element.jshint.JSHINT.addModule">
        function <span class="apidocSignatureSpan">jshint.JSHINT.</span>addModule
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addModule = function (func) {
  extraModules.push(func);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

// Modules.
itself.addModule = function(func) {
  extraModules.push(func);
};

itself.<span class="apidocCodeKeywordSpan">addModule</span>(style.register);

// Data summary.
itself.data = function() {
  var data = {
    functions: [],
    options: state.option
  };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.JSHINT.data" id="apidoc.element.jshint.JSHINT.data">
        function <span class="apidocSignatureSpan">jshint.JSHINT.</span>data
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">data = function () {
  var data = {
    functions: [],
    options: state.option
  };

  var fu, f, i, j, n, globals;

  if (itself.errors.length) {
    data.errors = itself.errors;
  }

  if (state.jsonMode) {
    data.json = true;
  }

  var impliedGlobals = state.funct[&#x22;(scope)&#x22;].getImpliedGlobals();
  if (impliedGlobals.length &#x3e; 0) {
    data.implieds = impliedGlobals;
  }

  if (urls.length &#x3e; 0) {
    data.urls = urls;
  }

  globals = state.funct[&#x22;(scope)&#x22;].getUsedOrDefinedGlobals();
  if (globals.length &#x3e; 0) {
    data.globals = globals;
  }

  for (i = 1; i &#x3c; functions.length; i += 1) {
    f = functions[i];
    fu = {};

    for (j = 0; j &#x3c; functionicity.length; j += 1) {
      fu[functionicity[j]] = [];
    }

    for (j = 0; j &#x3c; functionicity.length; j += 1) {
      if (fu[functionicity[j]].length === 0) {
        delete fu[functionicity[j]];
      }
    }

    fu.name = f[&#x22;(name)&#x22;];
    fu.param = f[&#x22;(params)&#x22;];
    fu.line = f[&#x22;(line)&#x22;];
    fu.character = f[&#x22;(character)&#x22;];
    fu.last = f[&#x22;(last)&#x22;];
    fu.lastcharacter = f[&#x22;(lastcharacter)&#x22;];

    fu.metrics = {
      complexity: f[&#x22;(metrics)&#x22;].ComplexityCount,
      parameters: f[&#x22;(metrics)&#x22;].arity,
      statements: f[&#x22;(metrics)&#x22;].statementCount
    };

    data.functions.push(fu);
  }

  var unuseds = state.funct[&#x22;(scope)&#x22;].getUnuseds();
  if (unuseds.length &#x3e; 0) {
    data.unused = unuseds;
  }

  for (n in member) {
    if (typeof member[n] === &#x22;number&#x22;) {
      data.member = member;
      break;
    }
  }

  return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.JSHINT.jshint" id="apidoc.element.jshint.JSHINT.jshint">
        function <span class="apidocSignatureSpan">jshint.JSHINT.</span>jshint
        <span class="apidocSignatureSpan">(s, o, g)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jshint = function (s, o, g) {
  var x, reIgnoreStr, reIgnore;
  var optionKeys;
  var newOptionObj = {};
  var newIgnoredObj = {};

  o = _.clone(o);
  state.reset();

  if (o &#x26;&#x26; o.scope) {
    JSHINT.scope = o.scope;
  } else {
    JSHINT.errors = [];
    JSHINT.undefs = [];
    JSHINT.internals = [];
    JSHINT.blacklist = {};
    JSHINT.scope = &#x22;(main)&#x22;;
  }

  predefined = Object.create(null);
  combine(predefined, vars.ecmaIdentifiers[3]);
  combine(predefined, vars.reservedVars);

  combine(predefined, g || {});

  declared = Object.create(null);
  var exported = Object.create(null); // Variables that live outside the current file

  function each(obj, cb) {
    if (!obj)
      return;

    if (!Array.isArray(obj) &#x26;&#x26; typeof obj === &#x22;object&#x22;)
      obj = Object.keys(obj);

    obj.forEach(cb);
  }

  if (o) {
    each(o.predef || null, function(item) {
      var slice, prop;

      if (item[0] === &#x22;-&#x22;) {
        slice = item.slice(1);
        JSHINT.blacklist[slice] = slice;
        // remove from predefined if there
        delete predefined[slice];
      } else {
        prop = Object.getOwnPropertyDescriptor(o.predef, item);
        predefined[item] = prop ? prop.value : false;
      }
    });

    each(o.exported || null, function(item) {
      exported[item] = true;
    });

    delete o.predef;
    delete o.exported;

    optionKeys = Object.keys(o);
    for (x = 0; x &#x3c; optionKeys.length; x++) {
      if (/^-W\d{3}$/g.test(optionKeys[x])) {
        newIgnoredObj[optionKeys[x].slice(1)] = true;
      } else {
        var optionKey = optionKeys[x];
        newOptionObj[optionKey] = o[optionKey];
      }
    }
  }

  state.option = newOptionObj;
  state.ignored = newIgnoredObj;

  state.option.indent = state.option.indent || 4;
  state.option.maxerr = state.option.maxerr || 50;

  indent = 1;

  var scopeManagerInst = scopeManager(state, predefined, exported, declared);
  scopeManagerInst.on(&#x22;warning&#x22;, function(ev) {
    warning.apply(null, [ ev.code, ev.token].concat(ev.data));
  });

  scopeManagerInst.on(&#x22;error&#x22;, function(ev) {
    error.apply(null, [ ev.code, ev.token ].concat(ev.data));
  });

  state.funct = functor(&#x22;(global)&#x22;, null, {
    &#x22;(global)&#x22;    : true,
    &#x22;(scope)&#x22;     : scopeManagerInst,
    &#x22;(comparray)&#x22; : arrayComprehension(),
    &#x22;(metrics)&#x22;   : createMetrics(state.tokens.next)
  });

  functions = [state.funct];
  urls = [];
  stack = null;
  member = {};
  membersOnly = null;
  inblock = false;
  lookahead = [];

  if (!isString(s) &#x26;&#x26; !Array.isArray(s)) {
    errorAt(&#x22;E004&#x22;, 0);
    return false;
  }

  api = {
    get isJSON() {
      return state.jsonMode;
    },

    getOption: function(name) {
      return state.option[name] || null;
    },

    getCache: function(name) {
      return state.cache[name];
    },

    setCache: function(name, value) {
      state.cache[name] = value;
    },

    warn: function(code, data) {
      warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
    },

    on: function(names, listener) {
      names.split(&#x22; &#x22;).forEach(function(name) {
        emitter.on(name, listener);
      }.bind(this));
    }
  };

  emitter.removeAllListeners();
  (extraModules || []).forEach(function(func) {
    func(api);
  });

  state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[&#x22;(begin)&#x22;];

  if (o &#x26;&#x26; o.ignoreDelimiters) {

    if (!Array.isArray(o.ignoreDelimiters)) {
      o.ignoreDelimiters = [o.ignoreDelimiters];
    }

    o.ignoreDelimiters.forEach(function(delimiterPair) {
      if (!delimiterPair.start || !delimiterPair.end)
          return;

      reIgnoreStr = escapeRegex(delimiterPair.start) +
                    &#x22;[\\s\\S]*?&#x22; +
                    escapeRegex(delimiterPair.end);

      reIgnore = new RegExp(reIgnoreStr, &#x22;ig&#x22;);

      s = s.replace(reIgnore, function(match) {
        return match.replace(/./g, &#x22; &#x22;);
      });
    });
  }

  lex = new Lexer(s);

  lex.on(&#x22;warning&#x22;, function(ev) {
    warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
  });

  lex.on(&#x22;error&#x22;, function(ev) {
    errorAt.apply(null ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.jshint" id="apidoc.module.jshint.jshint">module jshint.jshint</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.jshint.JSHINT" id="apidoc.element.jshint.jshint.JSHINT">
        function <span class="apidocSignatureSpan">jshint.jshint.</span>JSHINT
        <span class="apidocSignatureSpan">(s, o, g)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSHINT = function (s, o, g) {
  var x, reIgnoreStr, reIgnore;
  var optionKeys;
  var newOptionObj = {};
  var newIgnoredObj = {};

  o = _.clone(o);
  state.reset();

  if (o &#x26;&#x26; o.scope) {
    JSHINT.scope = o.scope;
  } else {
    JSHINT.errors = [];
    JSHINT.undefs = [];
    JSHINT.internals = [];
    JSHINT.blacklist = {};
    JSHINT.scope = &#x22;(main)&#x22;;
  }

  predefined = Object.create(null);
  combine(predefined, vars.ecmaIdentifiers[3]);
  combine(predefined, vars.reservedVars);

  combine(predefined, g || {});

  declared = Object.create(null);
  var exported = Object.create(null); // Variables that live outside the current file

  function each(obj, cb) {
    if (!obj)
      return;

    if (!Array.isArray(obj) &#x26;&#x26; typeof obj === &#x22;object&#x22;)
      obj = Object.keys(obj);

    obj.forEach(cb);
  }

  if (o) {
    each(o.predef || null, function(item) {
      var slice, prop;

      if (item[0] === &#x22;-&#x22;) {
        slice = item.slice(1);
        JSHINT.blacklist[slice] = slice;
        // remove from predefined if there
        delete predefined[slice];
      } else {
        prop = Object.getOwnPropertyDescriptor(o.predef, item);
        predefined[item] = prop ? prop.value : false;
      }
    });

    each(o.exported || null, function(item) {
      exported[item] = true;
    });

    delete o.predef;
    delete o.exported;

    optionKeys = Object.keys(o);
    for (x = 0; x &#x3c; optionKeys.length; x++) {
      if (/^-W\d{3}$/g.test(optionKeys[x])) {
        newIgnoredObj[optionKeys[x].slice(1)] = true;
      } else {
        var optionKey = optionKeys[x];
        newOptionObj[optionKey] = o[optionKey];
      }
    }
  }

  state.option = newOptionObj;
  state.ignored = newIgnoredObj;

  state.option.indent = state.option.indent || 4;
  state.option.maxerr = state.option.maxerr || 50;

  indent = 1;

  var scopeManagerInst = scopeManager(state, predefined, exported, declared);
  scopeManagerInst.on(&#x22;warning&#x22;, function(ev) {
    warning.apply(null, [ ev.code, ev.token].concat(ev.data));
  });

  scopeManagerInst.on(&#x22;error&#x22;, function(ev) {
    error.apply(null, [ ev.code, ev.token ].concat(ev.data));
  });

  state.funct = functor(&#x22;(global)&#x22;, null, {
    &#x22;(global)&#x22;    : true,
    &#x22;(scope)&#x22;     : scopeManagerInst,
    &#x22;(comparray)&#x22; : arrayComprehension(),
    &#x22;(metrics)&#x22;   : createMetrics(state.tokens.next)
  });

  functions = [state.funct];
  urls = [];
  stack = null;
  member = {};
  membersOnly = null;
  inblock = false;
  lookahead = [];

  if (!isString(s) &#x26;&#x26; !Array.isArray(s)) {
    errorAt(&#x22;E004&#x22;, 0);
    return false;
  }

  api = {
    get isJSON() {
      return state.jsonMode;
    },

    getOption: function(name) {
      return state.option[name] || null;
    },

    getCache: function(name) {
      return state.cache[name];
    },

    setCache: function(name, value) {
      state.cache[name] = value;
    },

    warn: function(code, data) {
      warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
    },

    on: function(names, listener) {
      names.split(&#x22; &#x22;).forEach(function(name) {
        emitter.on(name, listener);
      }.bind(this));
    }
  };

  emitter.removeAllListeners();
  (extraModules || []).forEach(function(func) {
    func(api);
  });

  state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[&#x22;(begin)&#x22;];

  if (o &#x26;&#x26; o.ignoreDelimiters) {

    if (!Array.isArray(o.ignoreDelimiters)) {
      o.ignoreDelimiters = [o.ignoreDelimiters];
    }

    o.ignoreDelimiters.forEach(function(delimiterPair) {
      if (!delimiterPair.start || !delimiterPair.end)
          return;

      reIgnoreStr = escapeRegex(delimiterPair.start) +
                    &#x22;[\\s\\S]*?&#x22; +
                    escapeRegex(delimiterPair.end);

      reIgnore = new RegExp(reIgnoreStr, &#x22;ig&#x22;);

      s = s.replace(reIgnore, function(match) {
        return match.replace(/./g, &#x22; &#x22;);
      });
    });
  }

  lex = new Lexer(s);

  lex.on(&#x22;warning&#x22;, function(ev) {
    warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
  });

  lex.on(&#x22;error&#x22;, function(ev) {
    errorAt.apply(null ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.lex" id="apidoc.module.jshint.lex">module jshint.lex</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.lex.Lexer" id="apidoc.element.jshint.lex.Lexer">
        function <span class="apidocSignatureSpan">jshint.lex.</span>Lexer
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lexer(source) {
  var lines = source;

  if (typeof lines === &#x22;string&#x22;) {
    lines = lines
      .replace(/\r\n/g, &#x22;\n&#x22;)
      .replace(/\r/g, &#x22;\n&#x22;)
      .split(&#x22;\n&#x22;);
  }

  // If the first line is a shebang (#!), make it a blank and move on.
  // Shebangs are used by Node scripts.

  if (lines[0] &#x26;&#x26; lines[0].substr(0, 2) === &#x22;#!&#x22;) {
    if (lines[0].indexOf(&#x22;node&#x22;) !== -1) {
      state.option.node = true;
    }
    lines[0] = &#x22;&#x22;;
  }

  this.emitter = new events.EventEmitter();
  this.source = source;
  this.setLines(lines);
  this.prereg = true;

  this.line = 0;
  this.char = 1;
  this.from = 1;
  this.input = &#x22;&#x22;;
  this.inComment = false;
  this.context = [];
  this.templateStarts = [];

  for (var i = 0; i &#x3c; state.option.indent; i += 1) {
    state.tab += &#x22; &#x22;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.name_stack" id="apidoc.module.jshint.name_stack">module jshint.name_stack</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.name_stack.name_stack" id="apidoc.element.jshint.name_stack.name_stack">
        function <span class="apidocSignatureSpan">jshint.</span>name_stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NameStack() {
  this._stack = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.name_stack.prototype" id="apidoc.module.jshint.name_stack.prototype">module jshint.name_stack.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.name_stack.prototype.infer" id="apidoc.element.jshint.name_stack.prototype.infer">
        function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>infer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">infer = function () {
  var nameToken = this._stack[this.length - 1];
  var prefix = &#x22;&#x22;;
  var type;

  // During expected operation, the topmost entry on the stack will only
  // reflect the current function&#x27;s name when the function is declared without
  // the `function` keyword (i.e. for in-line accessor methods). In other
  // cases, the `function` expression itself will introduce an empty entry on
  // the top of the stack, and this should be ignored.
  if (!nameToken || nameToken.type === &#x22;class&#x22;) {
    nameToken = this._stack[this.length - 2];
  }

  if (!nameToken) {
    return &#x22;(empty)&#x22;;
  }

  type = nameToken.type;

  if (type !== &#x22;(string)&#x22; &#x26;&#x26; type !== &#x22;(number)&#x22; &#x26;&#x26; type !== &#x22;(identifier)&#x22; &#x26;&#x26; type !== &#x22;default&#x22;) {
    return &#x22;(expression)&#x22;;
  }

  if (nameToken.accessorType) {
    prefix = nameToken.accessorType + &#x22; &#x22;;
  }

  return prefix + nameToken.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  isArrow = options.type === &#x22;arrow&#x22;;
  ignoreLoopFunc = options.ignoreLoopFunc;
}

state.option = Object.create(state.option);
state.ignored = Object.create(state.ignored);

state.funct = functor(name || state.nameStack.<span class="apidocCodeKeywordSpan">infer</span>(), state.tokens.next, {
  &#x22;(statement)&#x22;: statement,
  &#x22;(context)&#x22;:   state.funct,
  &#x22;(arrow)&#x22;:     isArrow,
  &#x22;(generator)&#x22;: isGenerator
});

f = state.funct;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.name_stack.prototype.pop" id="apidoc.element.jshint.name_stack.prototype.pop">
        function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  this._stack.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
  }
  if (isLetExpr) {
    state.funct[&#x22;(scope)&#x22;].unstack();
  }

  state.nameStack.<span class="apidocCodeKeywordSpan">pop</span>();

  return left;
}


// Functions for conformance of style.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.name_stack.prototype.push" id="apidoc.element.jshint.name_stack.prototype.push">
        function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>push
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function () {
  this._stack.push(null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  a: a,
  b: b,
  c: c,
  d: d
};

w.reason = supplant(msg.desc, w);
JSHINT.errors.<span class="apidocCodeKeywordSpan">push</span>(w);

removeIgnoredMessages();

if (JSHINT.errors.length &#x3e;= state.option.maxerr)
  quit(&#x22;E043&#x22;, t);

return w;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jshint.name_stack.prototype.set" id="apidoc.element.jshint.name_stack.prototype.set">
        function <span class="apidocSignatureSpan">jshint.name_stack.prototype.</span>set
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (token) {
  this._stack[this.length - 1] = token;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (left.id === &#x22;.&#x22;) {
  if (!left.left || left.left.value === &#x22;arguments&#x22; &#x26;&#x26; !state.isStrict()) {
    warning(&#x22;E031&#x22;, assignToken);
  }

  state.nameStack.<span class="apidocCodeKeywordSpan">set</span>(state.tokens.prev);
  return true;
} else if (left.id === &#x22;{&#x22; || left.id === &#x22;[&#x22;) {
  if (!allowDestructuring || !left.destructAssign) {
    if (left.id === &#x22;{&#x22; || !left.left) {
      warning(&#x22;E031&#x22;, assignToken);
    } else if (left.left.value === &#x22;arguments&#x22; &#x26;&#x26; !state.isStrict()) {
      warning(&#x22;E031&#x22;, assignToken);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jshint.style" id="apidoc.module.jshint.style">module jshint.style</a></h1>


    <h2>
        <a href="#apidoc.element.jshint.style.register" id="apidoc.element.jshint.style.register">
        function <span class="apidocSignatureSpan">jshint.style.</span>register
        <span class="apidocSignatureSpan">(linter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (linter) {
  // Check for properties named __proto__. This special property was
  // deprecated and then re-introduced for ES6.

  linter.on(&#x22;Identifier&#x22;, function style_scanProto(data) {
    if (linter.getOption(&#x22;proto&#x22;)) {
      return;
    }

    if (data.name === &#x22;__proto__&#x22;) {
      linter.warn(&#x22;W103&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.name, &#x22;6&#x22; ]
      });
    }
  });

  // Check for properties named __iterator__. This is a special property
  // available only in browsers with JavaScript 1.7 implementation, but
  // it is deprecated for ES6

  linter.on(&#x22;Identifier&#x22;, function style_scanIterator(data) {
    if (linter.getOption(&#x22;iterator&#x22;)) {
      return;
    }

    if (data.name === &#x22;__iterator__&#x22;) {
      linter.warn(&#x22;W103&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.name ]
      });
    }
  });

  // Check that all identifiers are using camelCase notation.
  // Exceptions: names like MY_VAR and _myVar.

  linter.on(&#x22;Identifier&#x22;, function style_scanCamelCase(data) {
    if (!linter.getOption(&#x22;camelcase&#x22;)) {
      return;
    }

    if (data.name.replace(/^_+|_+$/g, &#x22;&#x22;).indexOf(&#x22;_&#x22;) &#x3e; -1 &#x26;&#x26; !data.name.match(/^[A-Z0-9_]*$/)) {
      linter.warn(&#x22;W106&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.name ]
      });
    }
  });

  // Enforce consistency in style of quoting.

  linter.on(&#x22;String&#x22;, function style_scanQuotes(data) {
    var quotmark = linter.getOption(&#x22;quotmark&#x22;);
    var code;

    if (!quotmark) {
      return;
    }

    // If quotmark is set to &#x27;single&#x27; warn about all double-quotes.

    if (quotmark === &#x22;single&#x22; &#x26;&#x26; data.quote !== &#x22;&#x27;&#x22;) {
      code = &#x22;W109&#x22;;
    }

    // If quotmark is set to &#x27;double&#x27; warn about all single-quotes.

    if (quotmark === &#x22;double&#x22; &#x26;&#x26; data.quote !== &#x22;\&#x22;&#x22;) {
      code = &#x22;W108&#x22;;
    }

    // If quotmark is set to true, remember the first quotation style
    // and then warn about all others.

    if (quotmark === true) {
      if (!linter.getCache(&#x22;quotmark&#x22;)) {
        linter.setCache(&#x22;quotmark&#x22;, data.quote);
      }

      if (linter.getCache(&#x22;quotmark&#x22;) !== data.quote) {
        code = &#x22;W110&#x22;;
      }
    }

    if (code) {
      linter.warn(code, {
        line: data.line,
        char: data.char,
      });
    }
  });

  linter.on(&#x22;Number&#x22;, function style_scanNumbers(data) {
    if (data.value.charAt(0) === &#x22;.&#x22;) {
      // Warn about a leading decimal point.
      linter.warn(&#x22;W008&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.value ]
      });
    }

    if (data.value.substr(data.value.length - 1) === &#x22;.&#x22;) {
      // Warn about a trailing decimal point.
      linter.warn(&#x22;W047&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.value ]
      });
    }

    if (/^00+/.test(data.value)) {
      // Multiple leading zeroes.
      linter.warn(&#x22;W046&#x22;, {
        line: data.line,
        char: data.char,
        data: [ data.value ]
      });
    }
  });

  // Warn about script URLs.

  linter.on(&#x22;String&#x22;, function style_scanJavaScriptURLs(data) {
    var re = /^(?:javascript|jscript|ecmascript|vbscript|livescript)\s*:/i;

    if (linter.getOption(&#x22;scripturl&#x22;)) {
      return;
    }

    if (re.test(data.value)) {
      linter.warn(&#x22;W107&#x22;, {
        line: data.line,
        char: data.char
      });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
